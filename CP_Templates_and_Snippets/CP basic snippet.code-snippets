{
    "cp_snippet": {
        "scope": "cpp",
        "prefix": "cp_snippet",
        "body": [
            "#include <bits/stdc++.h>",
            // "#include <ext/numeric>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "#define INF INT_MAX",
            "#define LINF LONG_LONG_MAX",
            "#define int long long",
            "#define all(a) a.begin(), a.end()",
            "#define f first",
            "#define s second",
            "#define vi vector<int>",
            "#define vvi vector<vector<int>>",
            "#define vvvi vector<vector<vector<int>>>",
            "#define vii vector<pair<int, int>>",
            "#define seed chrono::high_resolution_clock::now().time_since_epoch().count()",
            "#define file_read(filepath) freopen(filepath, \"r\", stdin);",
            "#define file_write(filepath) freopen(filepath, \"w\", stdout);",
            "#define fastio                   \\",
            "    ios::sync_with_stdio(false); \\",
            "    cin.tie(0);                  \\",
            "    cout.tie(0)",
            "#define MOD 1000000007",
            "using namespace std;",
            "using pii = pair<int, int>;",
            // "using namespace __gnu_cxx;",
            "using namespace __gnu_pbds;",
            "template <typename T>",
            "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "",
            "template <typename A, typename B>",
            "ostream &operator<<(ostream &os, const pair<A, B> &p) {",
            "    return os << '(' << p.first << \", \" << p.second << ')';",
            "}",
            "",
            "template <typename T>",
            "void print(vector<T> &array, int size = numeric_limits<int>::max()) {",
            "    for (int i = 0; i < min<int>(size, array.size()); i++) {",
            "        cout << array[i] << \" \";",
            // "           print(array[i]);",
            "    }",
            "    cout << \"\\n\";",
            "}",
            "template <typename T>",
            "void print(T X) {",
            "    cout << X << \"\\n\";",
            "}",
            "template <typename T, typename... Ts>",
            "void print(T X, Ts... Y) {",
            "    cout << X << \" \";",
            "    print(Y...);",
            "}",
            "",
            "void solve(){",
            "    $0",
            "}",
            "",
            "signed main() {",
            "    fastio;",
            // "    $0",
            "    int t = 1;",
            "    // cin >> t;",
            "    while (t--){",
            // "        $0",
            "        solve();",
            "    }",
            "",
            "    return 0;",
            "}",
        ],
        "description": "The basic and versatile Competitive Programming template I currently use."
    },
    "for_snippet": {
        "scope": "cpp",
        "prefix": "forn",
        "body": [
            "for (int i = 0; i < n; i++) {",
            "    $0",
            "}",
        ],
        "description": "Simple snippet for repetitive for i loops."
    },
    "nested_for_snippet": {
        "scope": "cpp",
        "prefix": "fornm",
        "body": [
            "for (int i = 0; i < n; i++) {",
            "    for (int j = 0; j < m; j++) {",
            "        $0",
            "    }",
            "}",
        ],
        "description": "Simple snippet for repetitive for i loops."
    },
    "dijkstra_snippet": {
        "scope": "cpp",
        "prefix": "dijkstra",
        "body": [
            "vector<vector<pair<int, int>>> adj;",
            "vector<bool> visited;",
            "vector<int> dist;",
            "",
            "void dijkstra(int source) {",
            "    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
            "    dist[source] = 0;",
            "    pq.push({0, source});",
            "    while (!pq.empty()) {",
            "        int source = pq.top().second;",
            "        pq.pop();",
            "        if (visited[source]) {",
            "            continue;",
            "        }",
            "        visited[source] = true;",
            "            for (auto it : adj[source]) {",
            "                if (dist[it.first] > dist[source] + it.second) {",
            "                    dist[it.first] = dist[source] + it.second;",
            "                    pq.push({dist[it.first], it.first});",
            "            }",
            "        }",
            "    }",
            "}",
        ],
        "description": "Complete snippet for dijkstra's algorithm."
    },
    "n_input_snippet": {
        "scope": "cpp",
        "prefix": "nvector",
        "body": [
            "int n;",
            "cin >> n;",
            "vector<int> a(n);",
            "for (int i = 0; i < n; i++) {",
            "    cin >> a[i];",
            "}",
            "$0",
        ],
        "description": "Simple snippet for repetitive n codeforces input."
    },
    "nm_input_snippet": {
        "scope": "cpp",
        "prefix": "nmvector",
        "body": [
            "int n, m;",
            "cin >> n >> m;",
            "vector<vector<int>> a(n, vector<int>(m, 0));",
            "for (int i = 0; i < n; i++) {",
            "    for (int j = 0; j < m; j++) {",
            "        cin >> a[i][j];",
            "    }",
            "}",
            "$0",
        ],
        "description": "Simple snippet for repetitive nxm codeforces input."
    },
    "abdul_ahad_cp_snippet": {
        "scope": "cpp",
        "prefix": "abdul_ahad_cp_snippet",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "#define int long long int",
            "template <typename T>",
            "using ordered_set = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "#define ld long double",
            "#define nl cout << \"\\n\";",
            "#define getunique(v)                                  \\",
            "    {                                                 \\",
            "        sort(v.begin(), v.end());                     \\",
            "        v.erase(unique(v.begin(), v.end()), v.end()); \\",
            "    }",
            "#define forn(a, b) for (int i = a; i < b; i++)",
            "#define __builtin_popcountll __builtin_popcountll",
            "#define __builtin_clzll __builtin_clzll",
            "#define __builtin_ctzll __builtin_ctzll",
            "#define pii pair<int, int>",
            "#define mp(a, b) make_pair(a, b)",
            "#define pb push_back",
            "#define all(a) a.begin(), a.end()",
            "#define vi vector<int>",
            "#define hhh cout << \"here\" << endl;",
            "#define mod1 1000000007",
            "#define mod2 998244353",
            "",
            "signed main() {",
            "",
            "    return 0;",
            "}",
        ],
        "description": "The extensive and comprehensive Competitive Programming template that Abdul Ahad uses. He picked it from H_squared I believe."
    },
    "barebones_cp_snippet": {
        "scope": "cpp",
        "prefix": "barebones_cp_snippet",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "signed main() {",
            "    int t = 1;",
            "    // cin >> t;",
            "    while (t--) {",
            "        $0",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Barebones snippet for Teknofest'24"
    },
    "dsu_snippet": {
        "scope": "cpp",
        "prefix": "dsu_cp_snippet",
        "body": [
            "class DSU {",
            "    public:",
            "    int n;",
            "    vector<int> parent, size;",
            "",
            "    DSU(int n) {",
            "        this->n = n;",
            "        parent.assign(n,-1);",
            "        size.assign(n,0);",
            "        for (int i = 0; i < n; i++) {",
            "            make_set(i);",
            "        }",
            "    }",
            "",
            "    void make_set(int v) {",
            "        parent[v] = v;",
            "        size[v] = 1;",
            "    }",
            "",
            "    int find_set(int v) {",
            "        if (v == parent[v]) {",
            "            return v;",
            "        }",
            "        return parent[v] = find_set(parent[v]);",
            "    }",
            "",
            "    void union_set(int a, int b) {",
            "        a = find_set(a);",
            "        b = find_set(b);",
            "        if (a != b) {",
            "            if (size[a] < size[b])",
            "                swap(a, b);",
            "            parent[b] = a;",
            "            size[a] += size[b];",
            "        }",
            "    }",
            "",
            "    int total_sets() {",
            "        int total = 0;",
            "        for (int i = 1; i < parent.size(); i++) {",
            "            if (i == parent[i])",
            "                total++;",
            "        }",
            "        return total;",
            "    }",
            "};",
        ],
        "description": "DSU snippet for CC'24"
    },
    "LCA_snippet": {
        "scope": "cpp",
        "prefix": "lca",
        "body": [
            "adj.assign(n, vi());",
            "int maxbit = 21; // log2(n)",
            "vvi ancestor(maxbit + 1, vi(n, -1));",
            "for (int i = 1; i < n; i++) {",
            "    cin >> u;",
            "    u--;",
            "    ancestor[0][i] = u;",
            "    adj[u].push_back(i);",
            "    adj[i].push_back(u);",
            "}",
            "for (int i = 1; i <= maxbit; i++) {",
            "    for (int j = 0; j < n; j++) {",
            "        if (ancestor[i - 1][j] == -1)",
            "            continue;",
            "        ancestor[i][j] = ancestor[i - 1][ancestor[i - 1][j]];",
            "    }",
            "}"
        ]
    },
    "LCA of a and b_snippet": {
        "scope": "cpp",
        "prefix": "lca_of_a_and_b",
        "body": [
            "if (depth[a] > depth[b])",
            "    swap(a, b);",
            "int diff = depth[b] - depth[a];",
            "for (int j = maxbit; j >= 0; j--) {",
            "    if ((1 << j) <= diff) {",
            "        b = ancestor[j][b];",
            "        diff -= (1 << j);",
            "    }",
            "}",
            "if (a == b) {",
            "    print(a + 1);",
            "} else {",
            "    for (int j = maxbit; j >= 0; j--) {",
            "        if (ancestor[j][a] != -1 && (ancestor[j][a] != ancestor[j][b])) {",
            "            a = ancestor[j][a];",
            "            b = ancestor[j][b];",
            "        }",
            "    }",
            "    print(ancestor[0][a] + 1);",
            "}",
            ""
        ]
    },
    "Segment Tree_snippet": {
        "scope": "cpp",
        "prefix": "segment_tree",
        "body": [
            "class SegmentTree {",
            "public:",
            "    int n;",
            "    vi tree;",
            "    SegmentTree(vi &array) {",
            "        n = array.size();",
            "        tree.assign(4 * n, INF);",
            "        build(array, 1, 0, n - 1);",
            "    }",
            "    int f(int a, int b) {",
            "        return min(a, b);",
            "    }",
            "    void build(vi &array, int v, int tl, int tr) {",
            "        if (tl == tr) {",
            "            tree[v] = array[tl];",
            "        } else {",
            "            int tm = midpoint(tl, tr);",
            "            build(array, 2 * v, tl, tm);",
            "            build(array, 2 * v + 1, tm + 1, tr);",
            "            tree[v] = f(tree[2 * v], tree[2 * v + 1]);",
            "        }",
            "    }",
            "    int conquer(int v, int tl, int tr, int l, int r) {",
            "        if (l > r) {",
            "            return INF;",
            "        } else if (l == tl && r == tr) {",
            "            return tree[v];",
            "        } else {",
            "            int tm = midpoint(tl, tr);",
            "            int answer = f(conquer(2 * v, tl, tm, l, min(tm, r)), conquer(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));",
            "            return answer;",
            "        }",
            "    }",
            "};",
            ""
        ]
    },
    "Lazy Segment Tree_snippet": {
        "scope": "cpp",
        "prefix": "lazy_segment_tree",
        "body": [
            "class SegmentTree {",
            "public:",
            "    int n;",
            "    vi tree, lazy;",
            "    SegmentTree(vi &array) {",
            "        n = array.size();",
            "        tree.assign(4 * n, 0);",
            "        lazy.assign(4 * n, 0);",
            "        build(array, 1, 0, n - 1);",
            "    }",
            "    int f(int a, int b) {",
            "        return a + b;",
            "    }",
            "    void build(vi &array, int v, int tl, int tr) {",
            "        if (tl == tr) {",
            "            tree[v] = array[tl];",
            "        } else {",
            "            // int tm = midpoint(tl, tr);",
            "            int tm = (tl + tr) / 2;",
            "            build(array, v * 2, tl, tm);",
            "            build(array, v * 2 + 1, tm + 1, tr);",
            "            tree[v] = f(tree[v * 2], tree[v * 2 + 1]);",
            "        }",
            "    }",
            "    void updateRange(int v, int tl, int tr, int l, int r, int value) {",
            "        if (lazy[v] != 0) {",
            "            tree[v] += (tr - tl + 1) * lazy[v];",
            "            if (tl != tr) {",
            "                lazy[v * 2] += lazy[v];",
            "                lazy[v * 2 + 1] += lazy[v];",
            "            }",
            "            lazy[v] = 0;",
            "        }",
            "        if (l > r) {",
            "            return;",
            "        }",
            "        if (l == tl && r == tr) {",
            "            tree[v] += (tr - tl + 1) * value;",
            "            if (tl != tr) {",
            "                lazy[v * 2] += value;",
            "                lazy[v * 2 + 1] += value;",
            "            }",
            "            return;",
            "        }",
            "        // int tm = midpoint(tl, tr);",
            "        int tm = (tl + tr) / 2;",
            "        updateRange(v * 2, tl, tm, l, min(tm, r), value);",
            "        updateRange(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, value);",
            "        tree[v] = f(tree[v * 2], tree[v * 2 + 1]);",
            "    }",
            "    int query(int v, int tl, int tr, int l, int r) {",
            "        if (lazy[v] != 0) {",
            "            tree[v] += (tr - tl + 1) * lazy[v];",
            "            if (tl != tr) {",
            "                lazy[v * 2] += lazy[v];",
            "                lazy[v * 2 + 1] += lazy[v];",
            "            }",
            "            lazy[v] = 0;",
            "        }",
            "        if (l > r) {",
            "            return 0;",
            "        }",
            "        if (l == tl && r == tr) {",
            "            return tree[v];",
            "        }",
            "        // int tm = midpoint(tl, tr);",
            "        int tm = (tl + tr) / 2;",
            "        return f(query(v * 2, tl, tm, l, min(tm, r)), query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));",
            "    }",
            "};",
            ""
        ]
    },
    "Coordinate compression_snippet": {
        "scope": "cpp",
        "prefix": "coordinate_compression",
        "body": [
            "vector<int> a(n);",
            "vector<int> b = a;",
            "sort(b.begin(), b.end());",
            "map<int, int> m;",
            "for (int i = 0; i < n; i++) {",
            "    m[b[i]] = i;",
            "}",
            "for (int i = 0; i < n; i++) {",
            "    a[i] = m[a[i]]; // If you need the original value for a[i], you can just write b[a[i]].",
            "}",
            ""
        ]
    },
    "Matrix Exponentiation_snippet": {
        "scope": "cpp",
        "prefix": "matrix_exponentiation",
        "body": [
            "void multiply(vector<vector<int>> &A, vector<vector<int>> B) {",
            "    int n = A.size();",
            "    vector<vector<int>> X(n, vector<int>(n, 0));",
            "    for (int i = 0; i < n; i++) {",
            "        for (int j = 0; j < n; j++) {",
            "            X[i][j] = 0;",
            "            for (int k = 0; k < n; k++) {",
            "                X[i][j] += (A[i][k] * B[k][j]);",
            "                X[i][j] %= MOD;",
            "            }",
            "        }",
            "    }",
            "    A = X;",
            "}",
            "int n;",
            "cin >> n;",
            "vector<vector<int>> F = {{0, 1}, {1, 1}};",
            "vector<vector<int>> A = {{1, 0}, {0, 1}};",
            "while (n > 0) {",
            "    if (n & 1) {",
            "        multiply(A, F);",
            "    }",
            "    multiply(F, F);",
            "    n >>= 1;",
            "}",
            "multiply(A, {{1, 0}, {1, 0}});",
            "print(A[0][0]);",
            ""
        ]
    },
    "Kruskal_snippet": {
        "scope": "cpp",
        "prefix": "kruskal",
        "body": [
            "class Edge {",
            "public:",
            "    int u, v, w;",
            "};",
            "int n, m;",
            "vector<Edge> edgeList(m);",
            "DSU dsu(n);",
            "sort(all(edgeList), [](Edge &a, Edge &b) { return a.w < b.w; });",
            "int cost = 0;",
            "for (Edge e : edgeList) {",
            "    if (dsu.find_set(e.u) != dsu.find_set(e.v)) {",
            "        cost += e.w;",
            "        dsu.union_set(e.u, e.v);",
            "    }",
            "}",
            ""
        ]
    },
    "SCC_snippet": {
        "scope": "cpp",
        "prefix": "scc",
        "body": [
            "int n, m;",
            "vector<vector<int>> adj, adj2, components;",
            "vector<int> nodes, root;",
            "vector<bool> visited;",
            "void dfs(int v) {",
            "    visited[v] = true;",
            "    for (auto u : adj[v]) {",
            "        if (!visited[u]) {",
            "            dfs(u);",
            "        }",
            "    }",
            "    nodes.push_back(v);",
            "}",
            "void dfs2(int v) {",
            "    visited[v] = true;",
            "    components.back().push_back(v);",
            "    root[v] = components.size() - 1;",
            "    for (auto u : adj2[v]) {",
            "        if (!visited[u]) {",
            "            dfs2(u);",
            "        }",
            "    }",
            "}",
            "adj.assign(n, vector<int>());",
            "adj2.assign(n, vector<int>());",
            "visited.assign(n, false);",
            "root.assign(n, 0);",
            "for (int i = 0; i < n; i++) {",
            "    if (!visited[i]) {",
            "        dfs(i);",
            "    }",
            "}",
            "reverse(all(nodes));",
            "visited.assign(n, false);",
            "for (int i = 0; i < n; i++) {",
            "    if (!visited[nodes[i]]) {",
            "        components.push_back(vi());",
            "        dfs2(nodes[i]);",
            "    }",
            "}",
            ""
        ]
    },
    "Sieve of eratosthenes_snippet": {
        "scope": "cpp",
        "prefix": "sieve_of_eratosthenes",
        "body": [
            "vector<bool> prime(2e7 + 1, true);",
            "prime[0] = prime[1] = false;",
            "int n = 2e6 + 1;",
            "for (int p = 2; p <= n; p++) {",
            "    if (prime[p] == true) {",
            "        for (int i = p * p; i <= n; i += p)",
            "            prime[i] = false;",
            "    }",
            "}",
            ""
        ]
    },
    "Extended Euclidean Algorithm_snippet": {
        "scope": "cpp",
        "prefix": "extended_euclidean_algorithm",
        "body": [
            "int gcd(int a, int b, int &x, int &y) {",
            "    if (b == 0) {",
            "        x = 1;",
            "        y = 0;",
            "        return a;",
            "    }",
            "    int x1, y1;",
            "    int d = gcd(b, a % b, x1, y1);",
            "    x = y1;",
            "    y = x1 - y1 * (a / b);",
            "    return d;",
            "}",
            ""
        ]
    },
    "Inverse Mod using Extended Euclidean_snippet": {
        "scope": "cpp",
        "prefix": "inverse_mod_using_extended_euclidean",
        "body": [
            "int x, y;",
            "int g = extended_euclidean(a, m, x, y);",
            "if (g != 1) {",
            "    cout << \"No solution!\";",
            "} else {",
            "    x = (x % m + m) % m;",
            "    cout << x << endl;",
            "}",
            ""
        ]
    },
    "Modular Multiplication_snippet": {
        "scope": "cpp",
        "prefix": "modular_multiplication",
        "body": [
            "int binmult(int a, int b) {",
            "    if (b == 0) {",
            "        return 0;",
            "    }",
            "    int answer = binmult(a, b / 2) % MOD;",
            "    answer = (answer * 2) % MOD;",
            "    if (b & 1) {",
            "        answer = (answer + a) % MOD;",
            "    }",
            "    return answer;",
            "}",
            ""
        ]
    },
    "Modular Exponentiation_snippet": {
        "scope": "cpp",
        "prefix": "modular_exponentiation",
        "body": [
            "long long binpow(long long a, long long b) {",
            "    long long res = 1;",
            "    while (b > 0) {",
            "        if (b & 1)",
            "            res = res * a;",
            "        a = a * a;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            ""
        ]
    },
    "Z-function_snippet": {
        "scope": "cpp",
        "prefix": "z-function",
        "body": [
            "vector<int> z_function(string s) {",
            "    int n = s.size();",
            "    vector<int> z(n);",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; i++) {",
            "        if (i < r) {",
            "            z[i] = min(r - i, z[i - l]);",
            "        }",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
            "            z[i]++;",
            "        }",
            "        if (i + z[i] > r) {",
            "            l = i;",
            "            r = i + z[i];",
            "        }",
            "    }",
            "    return z;",
            "}",
            ""
        ]
    },
    "String Hashing_snippet": {
        "scope": "cpp",
        "prefix": "string_hashing",
        "body": [
            "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());",
            "const ll B = uniform_int_distribution<ll>(0, M - 1)(rng);",
            "class HashedString {",
            "public:",
            "    // change M and B if you want",
            "    static const long long M = 1e9 + 9; // 2^61 - 1",
            "    static const long long B = 9973;",
            "    // pow[i] contains B^i % M",
            "    static vector<long long> pow;",
            "    // p_hash[i] is the hash of the first i characters of the given string",
            "    vector<long long> p_hash;",
            "    HashedString(const string &s) : p_hash(s.size() + 1) {",
            "        while (pow.size() <= s.size()) {",
            "            pow.push_back((pow.back() * B) % M);",
            "        }",
            "        p_hash[0] = 0;",
            "        for (int i = 0; i < s.size(); i++) {",
            "            p_hash[i + 1] = ((p_hash[i] * B) % M + s[i]) % M;",
            "        }",
            "    }",
            "    long long get_hash(int start, int end) {",
            "        long long raw_val = (p_hash[end + 1] - (p_hash[start] * pow[end - start + 1]));",
            "        return (raw_val % M + M) % M;",
            "    }",
            "};",
            "vector<long long> HashedString::pow = {1};",
            ""
        ]
    },
    "Trie_snippet": {
        "scope": "cpp",
        "prefix": "trie",
        "body": [
            "class Trie {",
            "public:",
            "    Trie *child[26];",
            "    bool worldEnd;",
            "    Trie() {",
            "        for (int i = 0; i < 26; i++) {",
            "            child[i] = nullptr;",
            "        }",
            "        worldEnd = false;",
            "    }",
            "};",
            "void insert(Trie *root, string s) {",
            "    int n = s.size();",
            "    Trie *current = root;",
            "    for (int i = 0; i < n; i++) {",
            "        if (current->child[s[i] - 'a'] == nullptr) {",
            "            current->child[s[i] - 'a'] = new Trie();",
            "        }",
            "        current = current->child[s[i] - 'a'];",
            "    }",
            "    current->worldEnd = true;",
            "}",
            "bool search(Trie *root, string s) {",
            "    int n = s.size();",
            "    Trie *current = root;",
            "    for (int i = 0; i < n; i++) {",
            "        if (current->child[s[i] - 'a'] == nullptr) {",
            "            return false;",
            "        }",
            "        current = current->child[s[i] - 'a'];",
            "    }",
            "    return current->worldEnd;",
            "}",
            "void solve() {",
            "    Trie *root = new Trie();",
            "    vector<string> arr =",
            "        {\"and\", \"ant\", \"do\", \"geek\", \"dad\", \"ball\"};",
            "    for (const string &s : arr) {",
            "        insert(root, s);",
            "    }",
            "    // One by one search strings",
            "    vector<string> searchKeys = {\"do\", \"gee\", \"bat\"};",
            "    for (string &s : searchKeys) {",
            "        cout << \"Key : \" << s << \"\\n\";",
            "        if (search(root, s))",
            "            cout << \"Present\\n\";",
            "        else",
            "            cout << \"Not Present\\n\";",
            "    }",
            "}",
            ""
        ]
    },
    "FFT_snippet": {
        "scope": "cpp",
        "prefix": "fft",
        "body": [
            "using cd = complex<double>;",
            "const double PI = acos(-1);",
            "",
            "void fft(vector<cd> &a, bool invert) {",
            "    int n = a.size();",
            "    if (n == 1)",
            "        return;",
            "    vector<cd> a0(n / 2), a1(n / 2);",
            "    for (int i = 0; 2 * i < n; i++) {",
            "        a0[i] = a[2 * i];",
            "        a1[i] = a[2 * i + 1];",
            "    }",
            "    fft(a0, invert);",
            "    fft(a1, invert);",
            "    double ang = 2 * PI / n * (invert ? -1 : 1);",
            "    cd w(1), wn(cos(ang), sin(ang));",
            "    for (int i = 0; 2 * i < n; i++) {",
            "        a[i] = a0[i] + w * a1[i];",
            "        a[i + n / 2] = a0[i] - w * a1[i];",
            "        if (invert) {",
            "            a[i] /= 2;",
            "            a[i + n / 2] /= 2;",
            "        }",
            "        w *= wn;",
            "    }",
            "}",
            "vector<int> multiply(vector<int> const &a, vector<int> const &b) {",
            "    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());",
            "    int n = 1;",
            "    while (n < a.size() + b.size())",
            "        n <<= 1;",
            "    fa.resize(n);",
            "    fb.resize(n);",
            "    fft(fa, false);",
            "    fft(fb, false);",
            "    for (int i = 0; i < n; i++)",
            "        fa[i] *= fb[i];",
            "    fft(fa, true);",
            "    vector<int> result(n);",
            "    for (int i = 0; i < n; i++)",
            "        result[i] = round(fa[i].real());",
            "    return result;",
            "}",
            "void solve() {",
            "    string s, r;",
            "    cin >> s >> r;",
            "    int n = s.size(), m = r.size();",
            "    char bases[4] = {'A', 'C', 'G', 'T'};",
            "    int minHamming = LLONG_MAX;",
            "    vector<int> hammingDistance(n, 0);",
            "    for (char base : bases) {",
            "        vector<int> sBinary(n, 0), rBinary(m, 0);",
            "        for (int i = 0; i < n; i++)",
            "            sBinary[i] = (s[i] == base);",
            "        for (int i = 0; i < m; i++)",
            "            rBinary[m - i - 1] = !(r[i] == base);",
            "        vector<int> matchCount = multiply(sBinary, rBinary);",
            "        for (int i = m - 1; i < n; i++) {",
            "            int matches = matchCount[i];",
            "            hammingDistance[i] += matches;",
            "        }",
            "    }",
            "    for (int i = m - 1; i < n; i++) {",
            "        minHamming = min(minHamming, hammingDistance[i]);",
            "    }",
            "    cout << minHamming << endl;",
            "}",
            ""
        ]
    },
    "NTT_snippet": {
        "scope": "cpp",
        "prefix": "ntt",
        "body": [
            "const int mod = 7340033;",
            "const int root = 5;",
            "const int root_1 = 4404020;",
            "const int root_pw = 1 << 20;",
            "void fft(vector<int> &a, bool invert) {",
            "    int n = a.size();",
            "    for (int i = 1, j = 0; i < n; i++) {",
            "        int bit = n >> 1;",
            "        for (; j & bit; bit >>= 1)",
            "            j ^= bit;",
            "        j ^= bit;",
            "        if (i < j)",
            "            swap(a[i], a[j]);",
            "    }",
            "    for (int len = 2; len <= n; len <<= 1) {",
            "        int wlen = invert ? root_1 : root;",
            "        for (int i = len; i < root_pw; i <<= 1)",
            "            wlen = (int)(1LL * wlen * wlen % mod);",
            "        for (int i = 0; i < n; i += len) {",
            "            int w = 1;",
            "            for (int j = 0; j < len / 2; j++) {",
            "                int u = a[i + j], v = (int)(1LL * a[i + j + len / 2] * w % mod);",
            "                a[i + j] = u + v < mod ? u + v : u + v - mod;",
            "                a[i + j + len / 2] = u - v >= 0 ? u - v : u - v + mod;",
            "                w = (int)(1LL * w * wlen % mod);",
            "            }",
            "        }",
            "    }",
            "    if (invert) {",
            "        int n_1 = inverse(n, mod);",
            "        for (int &x : a)",
            "            x = (int)(1LL * x * n_1 % mod);",
            "    }",
            "}",
            ""
        ]
    },
}