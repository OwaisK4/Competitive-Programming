{
    "top-level": [
        {
            "LCA_snippet": {
                "scope": "cpp",
                "prefix": "lca",
                "body": [
                    "adj.assign(n, vi());",
                    "int maxbit = 21; // log2(n)",
                    "vvi ancestor(maxbit + 1, vi(n, -1));",
                    "for (int i = 1; i < n; i++) {",
                    "    cin >> u;",
                    "    u--;",
                    "    ancestor[0][i] = u;",
                    "    adj[u].push_back(i);",
                    "    adj[i].push_back(u);",
                    "}",
                    "for (int i = 1; i <= maxbit; i++) {",
                    "    for (int j = 0; j < n; j++) {",
                    "        if (ancestor[i - 1][j] == -1)",
                    "            continue;",
                    "        ancestor[i][j] = ancestor[i - 1][ancestor[i - 1][j]];",
                    "    }",
                    "}"
                ]
            }
        },
        {
            "LCA of a and b_snippet": {
                "scope": "cpp",
                "prefix": "lca_of_a_and_b",
                "body": [
                    "if (depth[a] > depth[b])",
                    "    swap(a, b);",
                    "int diff = depth[b] - depth[a];",
                    "for (int j = maxbit; j >= 0; j--) {",
                    "    if ((1 << j) <= diff) {",
                    "        b = ancestor[j][b];",
                    "        diff -= (1 << j);",
                    "    }",
                    "}",
                    "if (a == b) {",
                    "    print(a + 1);",
                    "} else {",
                    "    for (int j = maxbit; j >= 0; j--) {",
                    "        if (ancestor[j][a] != -1 && (ancestor[j][a] != ancestor[j][b])) {",
                    "            a = ancestor[j][a];",
                    "            b = ancestor[j][b];",
                    "        }",
                    "    }",
                    "    print(ancestor[0][a] + 1);",
                    "}",
                    ""
                ]
            }
        },
        {
            "Segment Tree_snippet": {
                "scope": "cpp",
                "prefix": "segment_tree",
                "body": [
                    "class SegmentTree {",
                    "public:",
                    "    int n;",
                    "    vi tree;",
                    "    SegmentTree(vi &array) {",
                    "        n = array.size();",
                    "        tree.assign(4 * n, INF);",
                    "        build(array, 1, 0, n - 1);",
                    "    }",
                    "    int f(int a, int b) {",
                    "        return min(a, b);",
                    "    }",
                    "    void build(vi &array, int v, int tl, int tr) {",
                    "        if (tl == tr) {",
                    "            tree[v] = array[tl];",
                    "        } else {",
                    "            int tm = midpoint(tl, tr);",
                    "            build(array, 2 * v, tl, tm);",
                    "            build(array, 2 * v + 1, tm + 1, tr);",
                    "            tree[v] = f(tree[2 * v], tree[2 * v + 1]);",
                    "        }",
                    "    }",
                    "    int conquer(int v, int tl, int tr, int l, int r) {",
                    "        if (l > r) {",
                    "            return INF;",
                    "        } else if (l == tl && r == tr) {",
                    "            return tree[v];",
                    "        } else {",
                    "            int tm = midpoint(tl, tr);",
                    "            int answer = f(conquer(2 * v, tl, tm, l, min(tm, r)), conquer(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));",
                    "            return answer;",
                    "        }",
                    "    }",
                    "};",
                    ""
                ]
            }
        },
        {
            "Lazy Segment Tree_snippet": {
                "scope": "cpp",
                "prefix": "lazy_segment_tree",
                "body": [
                    "class SegmentTree {",
                    "public:",
                    "    int n;",
                    "    vi tree, lazy;",
                    "    SegmentTree(vi &array) {",
                    "        n = array.size();",
                    "        tree.assign(4 * n, 0);",
                    "        lazy.assign(4 * n, 0);",
                    "        build(array, 1, 0, n - 1);",
                    "    }",
                    "    int f(int a, int b) {",
                    "        return a + b;",
                    "    }",
                    "    void build(vi &array, int v, int tl, int tr) {",
                    "        if (tl == tr) {",
                    "            tree[v] = array[tl];",
                    "        } else {",
                    "            // int tm = midpoint(tl, tr);",
                    "            int tm = (tl + tr) / 2;",
                    "            build(array, v * 2, tl, tm);",
                    "            build(array, v * 2 + 1, tm + 1, tr);",
                    "            tree[v] = f(tree[v * 2], tree[v * 2 + 1]);",
                    "        }",
                    "    }",
                    "    void updateRange(int v, int tl, int tr, int l, int r, int value) {",
                    "        if (lazy[v] != 0) {",
                    "            tree[v] += (tr - tl + 1) * lazy[v];",
                    "            if (tl != tr) {",
                    "                lazy[v * 2] += lazy[v];",
                    "                lazy[v * 2 + 1] += lazy[v];",
                    "            }",
                    "            lazy[v] = 0;",
                    "        }",
                    "        if (l > r) {",
                    "            return;",
                    "        }",
                    "        if (l == tl && r == tr) {",
                    "            tree[v] += (tr - tl + 1) * value;",
                    "            if (tl != tr) {",
                    "                lazy[v * 2] += value;",
                    "                lazy[v * 2 + 1] += value;",
                    "            }",
                    "            return;",
                    "        }",
                    "        // int tm = midpoint(tl, tr);",
                    "        int tm = (tl + tr) / 2;",
                    "        updateRange(v * 2, tl, tm, l, min(tm, r), value);",
                    "        updateRange(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, value);",
                    "        tree[v] = f(tree[v * 2], tree[v * 2 + 1]);",
                    "    }",
                    "    int query(int v, int tl, int tr, int l, int r) {",
                    "        if (lazy[v] != 0) {",
                    "            tree[v] += (tr - tl + 1) * lazy[v];",
                    "            if (tl != tr) {",
                    "                lazy[v * 2] += lazy[v];",
                    "                lazy[v * 2 + 1] += lazy[v];",
                    "            }",
                    "            lazy[v] = 0;",
                    "        }",
                    "        if (l > r) {",
                    "            return 0;",
                    "        }",
                    "        if (l == tl && r == tr) {",
                    "            return tree[v];",
                    "        }",
                    "        // int tm = midpoint(tl, tr);",
                    "        int tm = (tl + tr) / 2;",
                    "        return f(query(v * 2, tl, tm, l, min(tm, r)), query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));",
                    "    }",
                    "};",
                    ""
                ]
            }
        },
        {
            "Coordinate compression_snippet": {
                "scope": "cpp",
                "prefix": "coordinate_compression",
                "body": [
                    "vector<int> a(n);",
                    "vector<int> b = a;",
                    "sort(b.begin(), b.end());",
                    "map<int, int> m;",
                    "for (int i = 0; i < n; i++) {",
                    "    m[b[i]] = i;",
                    "}",
                    "for (int i = 0; i < n; i++) {",
                    "    a[i] = m[a[i]]; // If you need the original value for a[i], you can just write b[a[i]].",
                    "}",
                    ""
                ]
            }
        },
        {
            "Matrix Exponentiation_snippet": {
                "scope": "cpp",
                "prefix": "matrix_exponentiation",
                "body": [
                    "void multiply(vector<vector<int>> &A, vector<vector<int>> B) {",
                    "    int n = A.size();",
                    "    vector<vector<int>> X(n, vector<int>(n, 0));",
                    "    for (int i = 0; i < n; i++) {",
                    "        for (int j = 0; j < n; j++) {",
                    "            X[i][j] = 0;",
                    "            for (int k = 0; k < n; k++) {",
                    "                X[i][j] += (A[i][k] * B[k][j]);",
                    "                X[i][j] %= MOD;",
                    "            }",
                    "        }",
                    "    }",
                    "    A = X;",
                    "}",
                    "int n;",
                    "cin >> n;",
                    "vector<vector<int>> F = {{0, 1}, {1, 1}};",
                    "vector<vector<int>> A = {{1, 0}, {0, 1}};",
                    "while (n > 0) {",
                    "    if (n & 1) {",
                    "        multiply(A, F);",
                    "    }",
                    "    multiply(F, F);",
                    "    n >>= 1;",
                    "}",
                    "multiply(A, {{1, 0}, {1, 0}});",
                    "print(A[0][0]);",
                    ""
                ]
            }
        },
        {
            "Kruskal_snippet": {
                "scope": "cpp",
                "prefix": "kruskal",
                "body": [
                    "class Edge {",
                    "public:",
                    "    int u, v, w;",
                    "};",
                    "int n, m;",
                    "vector<Edge> edgeList(m);",
                    "DSU dsu(n);",
                    "sort(all(edgeList), [](Edge &a, Edge &b) { return a.w < b.w; });",
                    "int cost = 0;",
                    "for (Edge e : edgeList) {",
                    "    if (dsu.find_set(e.u) != dsu.find_set(e.v)) {",
                    "        cost += e.w;",
                    "        dsu.union_set(e.u, e.v);",
                    "    }",
                    "}",
                    ""
                ]
            }
        },
        {
            "SCC_snippet": {
                "scope": "cpp",
                "prefix": "scc",
                "body": [
                    "int n, m;",
                    "vector<vector<int>> adj, adj2, components;",
                    "vector<int> nodes, root;",
                    "vector<bool> visited;",
                    "void dfs(int v) {",
                    "    visited[v] = true;",
                    "    for (auto u : adj[v]) {",
                    "        if (!visited[u]) {",
                    "            dfs(u);",
                    "        }",
                    "    }",
                    "    nodes.push_back(v);",
                    "}",
                    "void dfs2(int v) {",
                    "    visited[v] = true;",
                    "    components.back().push_back(v);",
                    "    root[v] = components.size() - 1;",
                    "    for (auto u : adj2[v]) {",
                    "        if (!visited[u]) {",
                    "            dfs2(u);",
                    "        }",
                    "    }",
                    "}",
                    "adj.assign(n, vector<int>());",
                    "adj2.assign(n, vector<int>());",
                    "visited.assign(n, false);",
                    "root.assign(n, 0);",
                    "for (int i = 0; i < n; i++) {",
                    "    if (!visited[i]) {",
                    "        dfs(i);",
                    "    }",
                    "}",
                    "reverse(all(nodes));",
                    "visited.assign(n, false);",
                    "for (int i = 0; i < n; i++) {",
                    "    if (!visited[nodes[i]]) {",
                    "        components.push_back(vi());",
                    "        dfs2(nodes[i]);",
                    "    }",
                    "}",
                    ""
                ]
            }
        },
        {
            "Sieve of eratosthenes_snippet": {
                "scope": "cpp",
                "prefix": "sieve_of_eratosthenes",
                "body": [
                    "vector<bool> prime(2e7 + 1, true);",
                    "prime[0] = prime[1] = false;",
                    "int n = 2e6 + 1;",
                    "for (int p = 2; p <= n; p++) {",
                    "    if (prime[p] == true) {",
                    "        for (int i = p * p; i <= n; i += p)",
                    "            prime[i] = false;",
                    "    }",
                    "}",
                    ""
                ]
            }
        },
        {
            "Extended Euclidean Algorithm_snippet": {
                "scope": "cpp",
                "prefix": "extended_euclidean_algorithm",
                "body": [
                    "int gcd(int a, int b, int &x, int &y) {",
                    "    if (b == 0) {",
                    "        x = 1;",
                    "        y = 0;",
                    "        return a;",
                    "    }",
                    "    int x1, y1;",
                    "    int d = gcd(b, a % b, x1, y1);",
                    "    x = y1;",
                    "    y = x1 - y1 * (a / b);",
                    "    return d;",
                    "}",
                    ""
                ]
            }
        },
        {
            "Inverse Mod using Extended Euclidean_snippet": {
                "scope": "cpp",
                "prefix": "inverse_mod_using_extended_euclidean",
                "body": [
                    "int x, y;",
                    "int g = extended_euclidean(a, m, x, y);",
                    "if (g != 1) {",
                    "    cout << \"No solution!\";",
                    "} else {",
                    "    x = (x % m + m) % m;",
                    "    cout << x << endl;",
                    "}",
                    ""
                ]
            }
        },
        {
            "Modular Multiplication_snippet": {
                "scope": "cpp",
                "prefix": "modular_multiplication",
                "body": [
                    "int binmult(int a, int b) {",
                    "    if (b == 0) {",
                    "        return 0;",
                    "    }",
                    "    int answer = binmult(a, b / 2) % MOD;",
                    "    answer = (answer * 2) % MOD;",
                    "    if (b & 1) {",
                    "        answer = (answer + a) % MOD;",
                    "    }",
                    "    return answer;",
                    "}",
                    ""
                ]
            }
        },
        {
            "Modular Exponentiation_snippet": {
                "scope": "cpp",
                "prefix": "modular_exponentiation",
                "body": [
                    "long long binpow(long long a, long long b) {",
                    "    long long res = 1;",
                    "    while (b > 0) {",
                    "        if (b & 1)",
                    "            res = res * a;",
                    "        a = a * a;",
                    "        b >>= 1;",
                    "    }",
                    "    return res;",
                    "}",
                    ""
                ]
            }
        },
        {
            "Z-function_snippet": {
                "scope": "cpp",
                "prefix": "z-function",
                "body": [
                    "vector<int> z_function(string s) {",
                    "    int n = s.size();",
                    "    vector<int> z(n);",
                    "    int l = 0, r = 0;",
                    "    for (int i = 1; i < n; i++) {",
                    "        if (i < r) {",
                    "            z[i] = min(r - i, z[i - l]);",
                    "        }",
                    "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
                    "            z[i]++;",
                    "        }",
                    "        if (i + z[i] > r) {",
                    "            l = i;",
                    "            r = i + z[i];",
                    "        }",
                    "    }",
                    "    return z;",
                    "}",
                    ""
                ]
            }
        },
        {
            "String Hashing_snippet": {
                "scope": "cpp",
                "prefix": "string_hashing",
                "body": [
                    "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());",
                    "const ll B = uniform_int_distribution<ll>(0, M - 1)(rng);",
                    "class HashedString {",
                    "public:",
                    "    // change M and B if you want",
                    "    static const long long M = 1e9 + 9; // 2^61 - 1",
                    "    static const long long B = 9973;",
                    "    // pow[i] contains B^i % M",
                    "    static vector<long long> pow;",
                    "    // p_hash[i] is the hash of the first i characters of the given string",
                    "    vector<long long> p_hash;",
                    "    HashedString(const string &s) : p_hash(s.size() + 1) {",
                    "        while (pow.size() <= s.size()) {",
                    "            pow.push_back((pow.back() * B) % M);",
                    "        }",
                    "        p_hash[0] = 0;",
                    "        for (int i = 0; i < s.size(); i++) {",
                    "            p_hash[i + 1] = ((p_hash[i] * B) % M + s[i]) % M;",
                    "        }",
                    "    }",
                    "    long long get_hash(int start, int end) {",
                    "        long long raw_val = (p_hash[end + 1] - (p_hash[start] * pow[end - start + 1]));",
                    "        return (raw_val % M + M) % M;",
                    "    }",
                    "};",
                    "vector<long long> HashedString::pow = {1};",
                    ""
                ]
            }
        },
        {
            "Trie_snippet": {
                "scope": "cpp",
                "prefix": "trie",
                "body": [
                    "class Trie {",
                    "public:",
                    "    Trie *child[26];",
                    "    bool worldEnd;",
                    "    Trie() {",
                    "        for (int i = 0; i < 26; i++) {",
                    "            child[i] = nullptr;",
                    "        }",
                    "        worldEnd = false;",
                    "    }",
                    "};",
                    "void insert(Trie *root, string s) {",
                    "    int n = s.size();",
                    "    Trie *current = root;",
                    "    for (int i = 0; i < n; i++) {",
                    "        if (current->child[s[i] - 'a'] == nullptr) {",
                    "            current->child[s[i] - 'a'] = new Trie();",
                    "        }",
                    "        current = current->child[s[i] - 'a'];",
                    "    }",
                    "    current->worldEnd = true;",
                    "}",
                    "bool search(Trie *root, string s) {",
                    "    int n = s.size();",
                    "    Trie *current = root;",
                    "    for (int i = 0; i < n; i++) {",
                    "        if (current->child[s[i] - 'a'] == nullptr) {",
                    "            return false;",
                    "        }",
                    "        current = current->child[s[i] - 'a'];",
                    "    }",
                    "    return current->worldEnd;",
                    "}",
                    "void solve() {",
                    "    Trie *root = new Trie();",
                    "    vector<string> arr =",
                    "        {\"and\", \"ant\", \"do\", \"geek\", \"dad\", \"ball\"};",
                    "    for (const string &s : arr) {",
                    "        insert(root, s);",
                    "    }",
                    "    // One by one search strings",
                    "    vector<string> searchKeys = {\"do\", \"gee\", \"bat\"};",
                    "    for (string &s : searchKeys) {",
                    "        cout << \"Key : \" << s << \"\\n\";",
                    "        if (search(root, s))",
                    "            cout << \"Present\\n\";",
                    "        else",
                    "            cout << \"Not Present\\n\";",
                    "    }",
                    "}",
                    ""
                ]
            }
        }
    ]
}